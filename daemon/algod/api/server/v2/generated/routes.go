// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD///ADyAPhCwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
