// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
