// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"include": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
